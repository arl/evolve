package xover

import (
	"math/rand"

	"github.com/arl/evolve/generator"
)

// Mater is the interface implemented by objects defining the Mate function.
type Mater interface {

	// Mate performs crossover on a pair of parents to generate a pair of
	// offspring.
	//
	// parent1 and parent2 are the two individuals that provides the source
	// material for generating offspring.
	// TODO: should return 2 values of a slice of 2 values
	Mate(parent1, parent2 interface{},
		numberOfCrossoverPoints int64,
		rng *rand.Rand) []interface{}
}

// Crossover implements a standard crossover operator.
//
// It supports all crossover processes that operate on a pair of parent
// candidates.
// Both the number of crossovers points and the crossover probability are
// configurable. Crossover is applied to a proportion of selected parent pairs,
// with the remainder copied unchanged into the output population. The size of
// this evolved proportion is controlled by the code crossoverProbability
// parameter.
type Crossover struct {
	Mater
	Probability generator.Float
	Points      generator.Generator[int]
}

// New creates a Crossover operator based off the provided Mater.

// The returned Crossover performs a one point crossover with 1.0 (i.e always)
// probability.
func New(mater Mater) *Crossover {
	return &Crossover{Mater: mater}
}

// Apply applies the crossover operation to the selected candidates.
//
// Pairs of candidates are chosen randomly from the selected candidates and
// subjected to crossover to produce a pair of offspring candidates. The
// selected candidates, sel, are the evolved individuals that have survived to
// be eligible to reproduce.
//
// Returns the combined set of evolved offsprings generated by applying
// crossover to the selected candidates.
func (op *Crossover) Apply(sel []interface{}, rng *rand.Rand) []interface{} {
	// Shuffle the collection before applying each operation so that the
	// evolution is not influenced by any ordering artifacts from previous
	// operations.
	selcopy := make([]interface{}, len(sel))
	copy(selcopy, sel)

	rand.Shuffle(len(selcopy), func(i, j int) {
		selcopy[i], selcopy[j] = selcopy[j], selcopy[i]
	})

	res := make([]interface{}, 0, len(sel))
	for i := 0; i < len(selcopy); {
		p1 := selcopy[i]
		i++
		if i < len(selcopy) {
			p2 := selcopy[i]
			i++

			// get/decide a xover probability for this run
			prob := op.Probability.Next()

			npts := 0
			if rng.Float64() < prob {
				// we got a crossover to perform, get/decide the number of
				// crossover points
				npts = int(op.Points.Next())
			}
			if npts > 0 {
				res = append(res, op.Mate(p1, p2, int64(npts), rng)...)
			} else {
				// If there is no crossover to perform, just add the parents to the
				// results unaltered.
				res = append(res, p1, p2)
			}
		} else {
			// If we have an odd number of selected candidates, we can't pair up
			// the last one so just leave it unmodified.
			res = append(res, p1)
		}
	}
	return res
}
