package operators

import (
	"errors"
	"fmt"
	"math/rand"

	"github.com/aurelien-rainone/evolve/base"
	"github.com/aurelien-rainone/evolve/number"
)

// A Mater performs cross-over on a pair of parents to generate a pair of
// offspring.
//
// parent1 and parent2 are the two individuals that provides the source material
// for generating offspring.
type Mater interface {
	Mate(
		parent1, parent2 base.Candidate,
		numberOfCrossoverPoints int64,
		rng *rand.Rand) []base.Candidate
}

// WithConstantCrossoverPoints sets up a constant number of cross-over points.
func WithConstantCrossoverPoints(crossoverPoints int64) func(*AbstractCrossover) error {
	return func(op *AbstractCrossover) error {
		if crossoverPoints <= 0 {
			return errors.New("Number of cross-over points must be positive.")
		}
		op.crossoverPointsVariable = number.NewConstantIntegerGenerator(crossoverPoints)
		return nil
	}
}

// WithVariableCrossoverPoints sets up a variable number of cross-over points.
func WithVariableCrossoverPoints(variable number.IntegerGenerator) func(*AbstractCrossover) error {
	return func(op *AbstractCrossover) error {
		op.crossoverPointsVariable = variable
		return nil
	}
}

// WithConstantCrossoverProbability sets up a constant probability that, once
// selected, a pair of parents will be subjected to cross-over rather than being
// copied.
func WithConstantCrossoverProbability(crossoverProbability number.Probability) func(*AbstractCrossover) error {
	return func(op *AbstractCrossover) error {
		op.crossoverProbabilityVariable = number.NewConstantProbabilityGenerator(crossoverProbability)
		return nil
	}
}

// WithVariableCrossoverProbability sets up a variable probability that, once
// selected, a pair of parents will be subjected to cross-over rather than being
// copied.
func WithVariableCrossoverProbability(variable number.ProbabilityGenerator) func(*AbstractCrossover) error {
	return func(op *AbstractCrossover) error {
		op.crossoverProbabilityVariable = variable
		return nil
	}
}

// AbstractCrossover is a generic struct for cross-over implementations.
//
// It supports all cross-over processes that operate on a pair of parent
// candidates.
// Both the number of crossovers points and the crossover probability are
// configurable. Cross-over is applied to a proportion of selected parent pairs,
// with the remainder copied unchanged into the output population. The size of
// this evolved proportion is controlled by the code crossoverProbability
// parameter.
type AbstractCrossover struct {
	crossoverPointsVariable      number.IntegerGenerator
	crossoverProbabilityVariable number.ProbabilityGenerator
	Mater
}

// TODO: documentation
// TODO: example of use of how setting options with WithXXX functions
func NewAbstractCrossover(mater Mater, options ...func(*AbstractCrossover) error) (*AbstractCrossover, error) {
	// create with default options, 1 crossover point with a probability of 1
	op := &AbstractCrossover{
		crossoverPointsVariable:      number.NewConstantIntegerGenerator(1),
		crossoverProbabilityVariable: number.NewConstantProbabilityGenerator(number.ProbabilityOne),
		Mater: mater,
	}

	// set client options
	for _, option := range options {
		if err := option(op); err != nil {
			return op, fmt.Errorf("can't apply abstract crossover options: %v", err)
		}
	}
	return op, nil
}

// Apply applies the cross-over operation to the selected candidates.
//
// Pairs of candidates are chosen randomly and subjected to cross-over to
// produce a pair of offspring candidates.
//
// The selectedCandidates are the evolved individuals that have survived to be
// eligible to reproduce.
//
// It returns the combined set of evolved offspring generated by applying
// cross-over to the the selected candidates.
func (op *AbstractCrossover) Apply(selectedCandidates []base.Candidate, rng *rand.Rand) []base.Candidate {
	// Shuffle the collection before applying each operation so that the
	// evolution is not influenced by any ordering artifacts from previous
	// operations.
	selectionClone := make([]base.Candidate, len(selectedCandidates))
	copy(selectionClone, selectedCandidates)
	base.ShuffleCandidates(selectionClone, rng)

	result := make([]base.Candidate, 0, len(selectedCandidates))
	var iterator = 0
	for iterator < len(selectionClone) {
		parent1 := selectionClone[iterator]
		iterator++
		if iterator < len(selectionClone) {
			parent2 := selectionClone[iterator]
			iterator++
			// Randomly decide (according to the current cross-over probability)
			// whether to perform cross-over for these 2 parents.
			var crossoverPoints int64
			if op.crossoverProbabilityVariable.NextValue().NextEvent(rng) {
				crossoverPoints = op.crossoverPointsVariable.NextValue()
			}

			if crossoverPoints > 0 {
				result = append(result, op.Mate(parent1, parent2, crossoverPoints, rng)...)
			} else {
				// If there is no cross-over to perform, just add the parents to the
				// results unaltered.
				result = append(result, parent1)
				result = append(result, parent2)
			}
		} else {
			// If we have an odd number of selected candidates, we can't pair up
			// the last one so just leave it unmodified.
			result = append(result, parent1)
		}
	}
	return result
}
