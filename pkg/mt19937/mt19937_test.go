package mt19937_test

import (
	"hash/maphash"
	"math"
	"math/rand"
	"reflect"
	"testing"
	"time"

	"github.com/arl/evolve/pkg/mt19937"
)

// Test to ensure that two distinct RNGs with the same seed return the same
// sequence of numbers.
func TestMT19937Repeatability(t *testing.T) {
	const size = 512

	// Generate 2 sequences of the same size, using the same seed.
	var mt1, mt2 mt19937.MT19937
	seed := time.Now().UnixNano()
	mt1.Seed(seed)
	mt2.Seed(seed)
	rng1, rng2 := rand.New(&mt1), rand.New(&mt2)
	seq1 := make([]byte, size)
	rng1.Read(seq1)
	seq2 := make([]byte, size)
	rng2.Read(seq2)

	if !reflect.DeepEqual(seq1, seq2) {
		t.Logf("used seed: %d", seed)
		t.Errorf("sequences are not matching\n%v\n\n%v\n", seq1, seq2)
	}
}

// Test to ensure that the output from the RNG is broadly as expected. This will
// not detect the subtle statistical anomalies that would be picked up by
// Diehard, but it provides a simple check for major problems with the output.
func TestMT19937Distribution(t *testing.T) {
	pi := monteCarloValueForPi(rand.New(mt19937.New()), 1000000)

	diff := absDiff(pi, math.Pi)
	if diff > 0.01 {
		t.Errorf("got pi = %f want no more than 0.01 difference (math.Pi-pi = %v)", pi, diff)
	}
}

func absDiff(a, b float64) float64 {
	if a < b {
		return b - a
	}
	return a - b
}

// Rudimentary check to ensure the output of a PRNG is approximately uniformly
// distributed. This estimates the value of PI using a given number of
// iterations of the Monte Carlo simulation.
func monteCarloValueForPi(rng *rand.Rand, iterations int) float64 {
	var tot int
	for i := 0; i < iterations; i++ {
		x, y := rng.Float64(), rng.Float64()
		// Pythagora's distance to check if the point (x,y) is
		// inside the circle of diameter 1.
		if math.Sqrt((x*x)+(y*y)) <= 1 {
			tot++
		}
	}
	// If the PRNG generates an uniformly distributed sequence then this should
	// be a good approximation of Pi.
	return float64(4*tot) / float64(iterations)
}

func TestStandardDeviation(t *testing.T) {
	rng := rand.New(mt19937.New())

	// The standard deviation for a uniformly distributed population of values
	// in the range 0..n approaches n/sqrt(12).
	const n = 100
	stddev := calculateSampleStdDev(rng, n, 10000000)
	want := 100 / math.Sqrt(12)
	diff := absDiff(stddev, want)
	if diff > 0.02 {
		t.Errorf("got stddev = %f want no more than 0.02 difference (diff=%v)", stddev, diff)
	}
}

// Compute the standard deviation of the sequence of [0 max)
// values generated by the PRNG.
func calculateSampleStdDev(rng *rand.Rand, max, iterations int) float64 {
	vals := make([]float64, iterations)
	var sum float64
	for i := 0; i < iterations; i++ {
		v := float64(rng.Intn(max))
		sum += v
		vals[i] = v
	}

	mean := sum / float64(iterations)
	var sqdiffs float64
	for _, v := range vals {
		diff := mean - v
		sqdiffs += (diff * diff)
	}
	variance := sqdiffs / float64(iterations-1)
	return math.Sqrt(variance)
}

func BenchmarkMT19937Read(b *testing.B) {
	r := mt19937.New()
	p := make([]byte, 32)
	for n := 0; n < b.N; n++ {
		r.Read(p)
	}
}

var sink uint64

func BenchmarkMT19937Uint64(b *testing.B) {
	r := mt19937.New()
	for n := 0; n < b.N; n++ {
		sink = r.Uint64()
	}
}

func BenchmarkStdRandUint64(b *testing.B) {
	seed := int64(new(maphash.Hash).Sum64())
	r := rand.New(rand.NewSource(seed))
	for n := 0; n < b.N; n++ {
		sink = r.Uint64()
	}
}
